var m = /* @__PURE__ */ ((e) => (e.UserTokenGeneration = "user:tokens_generation", e.UserPreMFA = "user:pre_mfa", e.PostAuthentication = "user:post_authentication", e.M2MTokenGeneration = "m2m:token_generation", e.ExistingPasswordProvided = "user:existing_password_provided", e.NewPasswordProvided = "user:new_password_provided", e.PlanSelection = "user:plan_selection", e.PlanCancellationRequest = "user:plan_cancellation_request", e.UserPreRegistration = "user:pre_registration", e.NewUsernameProvided = "user:new_username_provided", e))(m || {}), b = /* @__PURE__ */ ((e) => (e.email = "email", e.profile = "profile", e.openid = "openid", e.offline_access = "offline", e))(b || {}), h = /* @__PURE__ */ ((e) => (e.none = "none", e.create = "create", e.login = "login", e))(h || {});
const v = "0.9.0", P = v, d = (e, n) => {
  if (!e || e.includes(".."))
    throw new Error("Invalid asset path");
  return `/${e}?${n ? `p_org_code=${n}&` : ""}cache=@8973ff883c2c40e1bad198b543e12b24@`;
}, p = {
  get(e, n, t) {
    return Reflect.get(e, n.toString(), t);
  },
  set(e, n, t) {
    return kinde.idToken.setCustomClaim(n, t), Reflect.set(e, n, t);
  }
}, E = {
  get(e, n, t) {
    return Reflect.get(e, n.toString(), t);
  },
  set(e, n, t) {
    return kinde.accessToken.setCustomClaim(n, t), Reflect.set(e, n, t);
  }
}, _ = {
  get(e, n, t) {
    return Reflect.get(e, n.toString(), t);
  },
  set(e, n, t) {
    return kinde.m2mToken.setCustomClaim(n, t), Reflect.set(e, n, t);
  }
};
function $() {
  if (!kinde.idToken)
    throw new Error(
      "IdToken binding not available, please add to workflow/page settings to enable"
    );
  const e = kinde.idToken.getCustomClaims();
  return new Proxy(
    e,
    p
  );
}
function j() {
  if (!kinde.accessToken)
    throw new Error(
      "accessToken binding not available, please add to workflow/page settings to enable"
    );
  const e = kinde.accessToken.getCustomClaims();
  return new Proxy(
    e,
    E
  );
}
function M() {
  if (!kinde.m2mToken)
    throw new Error(
      "m2mToken binding not available, please add to workflow/page settings to enable"
    );
  const e = kinde.m2mToken.getCustomClaims();
  return new Proxy(
    e,
    _
  );
}
function c(e) {
  if (!kinde.env)
    throw new Error(
      "env binding not available, please add to workflow/page settings to enable"
    );
  return kinde.env.get(e);
}
function U(e) {
  if (!kinde.localization)
    throw new Error(
      "localization binding not available, please add to workflow/page settings to enable"
    );
  return kinde.localization.get(e);
}
function K(e) {
  if (!kinde.auth)
    throw new Error("auth binding not available");
  kinde.auth.denyAccess(e);
}
function x(e, n) {
  if (!kinde.widget)
    throw new Error("widget binding not available");
  kinde.widget.invalidateFormField(e, n);
}
async function D(e, n) {
  if (!kinde.fetch)
    throw new Error("fetch binding not available");
  n.responseFormat || (n.responseFormat = "json");
  const t = await kinde.fetch(e, n);
  return {
    data: n.responseFormat === "json" ? t?.json : t.text
  };
}
function R(e) {
  if (!kinde.mfa)
    throw new Error(
      "mfa binding not available, please add to workflow settings to enable"
    );
  kinde.mfa.setEnforcementPolicy(e);
}
async function A(e, n) {
  if (!kinde.secureFetch)
    throw new Error("secureFetch binding not available");
  return n.responseFormat || (n.responseFormat = "json"), {
    data: (await kinde.secureFetch(e, n))?.json
  };
}
async function y(e, n) {
  const t = () => {
    if (!n.domain || !n.clientId || !n.clientSecret)
      throw new Error("getM2MToken: Missing required parameters");
    try {
      const i = kinde.fetch(`${n.domain}/oauth2/token`, {
        method: "POST",
        responseFormat: "json",
        headers: {
          "content-type": "application/x-www-form-urlencoded",
          accept: "application/json",
          ...n.headers
        },
        body: new URLSearchParams({
          audience: n.audience?.join(" ") ?? "",
          grant_type: "client_credentials",
          client_id: n.clientId,
          client_secret: n.clientSecret,
          scope: n.scopes?.join(" ") ?? ""
        })
      });
      if (!i.json?.access_token)
        throw new Error("getM2MToken: No access token returned");
      return i.json.access_token;
    } catch (i) {
      throw new Error(
        `getM2MToken: Failed to obtain token - ${i.message}`
      );
    }
  };
  return n.skipCache ? t() : await kinde.cache.jwtToken(e, {
    validation: {
      key: {
        type: "jwks",
        jwks: {
          url: `${n.domain}/.well-known/jwks.json`
        }
      }
    },
    onMissingOrExpired: t
  });
}
async function N(e, n) {
  let t, i;
  if (!URLSearchParams)
    throw new Error("url binding not available");
  if (n?.clientId && n?.clientSecret)
    t = n.clientId, i = n.clientSecret;
  else if (n?.clientIdKey && n?.clientSecretKey)
    t = c(n.clientIdKey)?.value, i = c(n.clientSecretKey)?.value;
  else {
    if (t = c("KINDE_WF_M2M_CLIENT_ID")?.value, i = c("KINDE_WF_M2M_CLIENT_SECRET")?.value, !t)
      throw new Error("M2M client ID not set");
    if (!i)
      throw new Error("M2M client secret not set");
  }
  let o = await y("internal_m2m_access_token", {
    domain: e.context.domains.kindeDomain,
    clientId: t,
    clientSecret: i,
    audience: [`${e.context.domains.kindeDomain}/api`],
    skipCache: n?.skipCache ?? !1
  });
  typeof o == "object" && (o = JSON.stringify(o), o = o.replace('"\\"', ""), o = o.replace('\\""', "")), o = o.replace(/"/g, "");
  const r = async ({
    method: a,
    endpoint: u,
    params: l,
    contentType: k = "application/json"
  }) => {
    let f;
    return l && (f = a === "GET" ? new URLSearchParams(l).toString() : l), { data: (await kinde.fetch(
      `${e.context.domains.kindeDomain}/api/v1/${u}`,
      {
        method: a,
        responseFormat: "json",
        headers: {
          authorization: `Bearer ${o}`,
          "Content-Type": k,
          accept: "application/json"
        },
        body: f ?? void 0
      }
    )).json };
  };
  return {
    get: async (a) => await r({ method: "GET", ...a }),
    post: async (a) => await r({ method: "POST", ...a }),
    patch: async (a) => await r({ method: "PATCH", ...a }),
    put: async (a) => await r({ method: "PUT", ...a }),
    delete: async (a) => await r({ method: "DELETE", ...a })
  };
}
const g = "@b1d3a51558e64036ad072b56ebae37f5@", w = "@847681e125384709836f921deb311104@", L = () => "@cd65da2987c740d58961024aa4a27194@", V = () => "@43dffdf2c22f40e9981303cb383f6fac@", G = () => "@ce0ef44d50f6408985f00c04a85d8430@", q = () => "@8103c7ff23fe49edb9b0537d2927e74e@", z = () => "@0c654432670c4d0292c3a0bc3c533247@", H = () => g, O = () => w, J = () => g, Q = () => w, X = () => "@09e41b34d7c04650aee6d26cafa152fc@", Y = (e) => d("logo", e), Z = (e) => d("logo_dark", e), W = (e) => d("favicon_svg", e), B = (e) => d("favicon_fallback", e), C = (e) => !e || /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$|^rgb\(.*\)$|^rgba\(.*\)$/.test(e), T = (e) => !e || /^(0|\d+(.(\d)+)?(%|px|rem|em))$/.test(e), F = (...e) => e.every(C) || void 0, S = (...e) => e.every(T) || void 0, ee = ({
  baseBackgroundColor: e,
  baseLinkColor: n,
  buttonBorderRadius: t,
  primaryButtonBackgroundColor: i,
  primaryButtonColor: s,
  cardBorderRadius: o,
  inputBorderRadius: r
}) => {
  if (!F(
    e,
    n,
    i,
    s
  ))
    throw console.log("baseBackgroundColor: ", e), console.log("baseLinkColor: ", n), console.log("primaryButtonBackgroundColor: ", i), console.log("primaryButtonColor: ", s), new Error("Invalid color value provided");
  if (!S(t, o, r))
    throw console.log("buttonBorderRadius: ", t), console.log("cardBorderRadius: ", o), console.log("inputBorderRadius: ", r), new Error("Invalid border radius value provided");
  return [
    e && `--kinde-designer-base-background-color: ${e};`,
    n && `--kinde-designer-base-link-color: ${n};`,
    o && `--kinde-designer-card-border-radius: ${o};`,
    t && `--kinde-designer-button-border-radius: ${t};`,
    r && `--kinde-designer-control-select-text-border-radius: ${r};`,
    i && `--kinde-designer-button-primary-background-color: ${i};`,
    s && `--kinde-designer-button-primary-color: ${s};`
  ].filter(Boolean).join(`
`);
}, ne = (e, n) => {
  if (!kinde.plan)
    throw new Error(
      "plan binding not available, please add to workflow/page settings to enable"
    );
  if (!e || typeof e != "string")
    throw new Error("Invalid message provided");
  kinde.plan.denySelection(e, n);
}, te = (e) => {
  if (!kinde.plan)
    throw new Error(
      "plan binding not available, please add to workflow/page settings to enable"
    );
  if (!e || typeof e != "string")
    throw new Error("Invalid message provided");
  kinde.plan.denyCancellation(e);
};
export {
  h as PromptTypes,
  b as Scopes,
  m as WorkflowTrigger,
  j as accessTokenCustomClaims,
  N as createKindeAPI,
  K as denyAccess,
  te as denyPlanCancellation,
  ne as denyPlanSelection,
  D as fetch,
  Z as getDarkModeLogoUrl,
  c as getEnvironmentVariable,
  B as getFallbackFaviconUrl,
  z as getKindeCSRF,
  O as getKindeLoginUrl,
  V as getKindeNonce,
  H as getKindeRegisterUrl,
  G as getKindeRequiredCSS,
  q as getKindeRequiredJS,
  Q as getKindeSignInUrl,
  J as getKindeSignUpUrl,
  X as getKindeThemeCode,
  L as getKindeWidget,
  U as getLocalization,
  Y as getLogoUrl,
  y as getM2MToken,
  W as getSVGFaviconUrl,
  $ as idTokenCustomClaims,
  x as invalidateFormField,
  M as m2mTokenClaims,
  A as secureFetch,
  R as setEnforcementPolicy,
  ee as setKindeDesignerCustomProperties,
  P as version
};
